
def lineCollision(startPoint, endPoint, direction):       
    slope = (endPoint.y - startPoint.y)/(endPoint.x - startPoint.x)
    
    for x in range(int(startPoint.x),int(endPoint.x)):
        
        y =  slope *(x  - endPoint.x) + endPoint.y
        screenPos = worldPoint_to_screenPoint(PVector(x,y))
        c = blockMap.get(int(screenPos.x),int(screenPos.y))            
        
        fill(c)
        ellipse(screenPos.x,screenPos.y,2,2)
        if c == color(104,255,147):
            return True
        
    return False
    
class Player():
    
    def __init__(self,x,y):
        
        self.position = PVector(x, y)
        self.acceleration = PVector(0,0)
        self.velocity = PVector(0,0)
        self.friction = .8
        self.maxSpeed = 2
        self.maxJump = 15
        self.playerDimensions = 15
        self.gravity = -0
        
    def display(self):
        screenPos = worldPoint_to_screenPoint(self.position)
        
        fill(0)
        rect(int(screenPos.x - self.playerDimensions/2), int(screenPos.y - self.playerDimensions/2), self.playerDimensions, self.playerDimensions)
        
    def applyForce(self,x ,y):
        
        self.acceleration.x += x
        self.acceleration.y += y
        
    def colorCollide(self):
        
        r1 = PVector(self.position.x + self.playerDimensions/2, self.position.y + self.playerDimensions/2)
        r2 = PVector(self.position.x + self.playerDimensions/2, self.position.y - self.playerDimensions/2)
        
        l1 = PVector(self.position.x - self.playerDimensions/2, self.position.y + self.playerDimensions/2)
        l2 = PVector(self.position.x - self.playerDimensions/2, self.position.y - self.playerDimensions/2)
        
        u1 = PVector(self.position.x + self.playerDimensions/4, self.position.y + self.playerDimensions/2 + self.velocity.y)
        u2 = PVector(self.position.x - self.playerDimensions/4, self.position.y + self.playerDimensions/2 + self.velocity.y)
        u3 = PVector(self.position.x - self.playerDimensions/2 + self.velocity.x, self.position.y + self.playerDimensions/2 + self.velocity.y)
        u4 = PVector(self.position.x + self.playerDimensions/2 + self.velocity.x, self.position.y + self.playerDimensions/2 + self.velocity.y)
        
        d1 = PVector(self.position.x + self.playerDimensions/4, self.position.y - self.playerDimensions/2 + self.velocity.y)
        d2 = PVector(self.position.x - self.playerDimensions/4, self.position.y - self.playerDimensions/2 + self.velocity.y)
        d3 = PVector(self.position.x - self.playerDimensions/2 + self.velocity.x, self.position.y + self.playerDimensions/2 + self.velocity.y)
        d4 = PVector(self.position.x + self.playerDimensions/2 + self.velocity.x, self.position.y + self.playerDimensions/2 + self.velocity.y)

        #lineD# = lineCollision(position, D#, 'direction')
        screenPos = worldPoint_to_screenPoint(self.position)

        lineR1 = lineCollision(screenPos, r1, 'right')
        lineR2 = lineCollision(screenPos, r2, 'right')
        lineL1 = lineCollision(screenPos, l1, 'left')
        lineL2 = lineCollision(screenPos, l2, 'left')
        
        lineU1 = lineCollision(screenPos, u1, 'up')
        lineU2 = lineCollision(screenPos, u2, 'up')
        lineU3 = lineCollision(screenPos, u3, 'up')
        lineU4 = lineCollision(screenPos, u4, 'up')
        
        lineD1 = lineCollision(screenPos, d1, 'down')
        lineD2 = lineCollision(screenPos, d2, 'down')
        lineD3 = lineCollision(screenPos, d3, 'down')
        lineD4 = lineCollision(screenPos, d4, 'down')
        
        self.grounded = False

        if  lineD1 == True or lineD2 == True or lineD3 == True or lineD4 == True:
            self.position.y -= -self.velocity.y
            self.velocity.y = 0
            self.grounded = True
            print('Ground') 
            
        if  lineR1 == True or lineR2 == True:
            #self.position.x += -self.velocity.x
            self.velocity.x = 0
            print('Right')
        
        if lineL1 == True or lineL2 == True:
            self.position.x -= -self.velocity.x
            self.velocity.x = 0
            print('Left')
            
        if  lineU1 == True or lineU2 == True or lineU3 == True or lineU4 == True:
            self.position.y += -self.velocity.y
            self.velocity.y = 0 
            print('Roof')
        
        print(lineL1,lineR1, lineU1, self.grounded)
        
    def update(self):
        self.applyForce(0,self.gravity)
                
        if keyArrays[0] == True:
            self.applyForce(-self.maxSpeed, 0)
        if keyArrays[1] == True:
            self.applyForce(self.maxSpeed,0)
        if keyArrays[2] == True and self.grounded == True:
            self.applyForce(0,self.maxJump)
    
        self.velocity.x += self.acceleration.x
        self.velocity.y += self.acceleration.y
        
        self.velocity.x *= self.friction
    
        self.colorCollide()
        
        self.position.x += self.velocity.x
        self.position.y += self.velocity.y

        self.acceleration = PVector(0,0)
        
        print('-----------------')
        self.display()
         
def worldPoint_to_screenPoint(worldPoints):
    return PVector((width/2 + worldPoints.x),(height/2 - worldPoints.y))

def setup():
    size(400,400)
    
    global blockMap
    blockMap = loadImage("cs_cpt_tr.png")
      
    global playerObj
    playerObj = Player(0,0)
    
    global keyArrays
    keyArrays = [False, False, False, False] 
    
    
def draw():
    #frameRate(20)
    background(blockMap)
    
    playerObj.update()
    
def keyPressed():
    
    if keyCode == LEFT or key == "a" :
        keyArrays[0] = True
    if keyCode == RIGHT or key == "d":
        keyArrays[1] = True
    if keyCode == UP or key == "w":
        keyArrays[2] = True 
def keyReleased():
    
    if keyCode == LEFT or key == "a":
        keyArrays[0] = False
    if keyCode == RIGHT or key == "d":
        keyArrays[1] = False
    if keyCode == UP or key == "w":
        keyArrays[2] = False 
